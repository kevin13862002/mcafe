<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>M Cafe Admin</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: { scgreen: '#00704A' },
            fontFamily: { sans: ['Inter','ui-sans-serif','system-ui'] }
          }
        }
      };
    </script>
    <style>
      .bg-scgreen { background-color: #00704A !important; }
      .text-scgreen { color: #00704A !important; }
      .border-scgreen { border-color: #00704A !important; }
    </style>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script>
      window.SUPABASE_URL = 'https://dqxgxjyliirsldztyelq.supabase.co';
      window.SUPABASE_ANON_KEY = 'sb_publishable_bZpsjO1rZ-y7URC8xn_IWw_PUwF1S8Y';
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.42.5/dist/umd/supabase.js"></script>
    <script src="./supabase-init.js"></script>
  </head>
  <body class="bg-gray-50 font-sans text-gray-800">
    <script>
      window.API_URL = window.API_URL || 'http://localhost:8000';
      window.adminSessionId = null;
    </script>
    <div id="admin-root" class="min-h-screen max-w-5xl mx-auto p-4 sm:p-6"></div>

    <script type="text/babel">
      const { useState, useEffect, useMemo, useRef } = React;

      // Simple client-side password gate. Change ADMIN_PASSWORD before deploying.
      const ADMIN_PASSWORD = window.ADMIN_PASSWORD || 'admin123';

      function AdminApp(){
        const [unlocked, setUnlocked] = useState(false);
        const [products, setProducts] = useState([]);
        const [orders, setOrders] = useState([]);
        const [groupBy, setGroupBy] = useState('none');

        const [user, setUser] = useState(null);

        useEffect(() => {
        const saved = sessionStorage.getItem('adminSessionId');
        if(saved){
          window.adminSessionId = saved;
          setUnlocked(true);
          setUser({ email: sessionStorage.getItem('adminEmail') || 'Admin' });
        }
      }, []);

        useEffect(() => {
          if(!user) return;
          setUnlocked(true);
          fetchProducts();
          fetchOrders();
        }, [user]);

        async function fetchProducts(){
          try{
              if (!window.supabaseClient) {
              console.error('Supabase not initialized');
              return;
            }
            
              const { data, error } = await window.supabaseClient
              .from('products')
              .select('*')
              .order('id');
            
            if (error) throw error;
            setProducts(data || []);
          }catch(e){
            console.error('fetchProducts error:', e.message);
            alert('Could not load products');
          }
        }

        async function fetchOrders(){
          try{
              if (!window.supabaseClient) {
              console.error('Supabase not initialized');
              alert('Supabase not initialized. Please refresh the page.');
              return;
            }
            
            console.log('Fetching orders from Supabase...');
              const { data, error } = await window.supabaseClient
              .from('orders')
              .select('*')
              .order('created_at', { ascending: false });
            
            if (error) {
              console.error('Supabase error:', error);
              throw error;
            }
            console.log('Orders fetched:', data);
            setOrders(data || []);
          }catch(e){
            console.error('fetchOrders error:', e);
            alert(`Could not load orders: ${e.message || JSON.stringify(e)}`);
          }
        }

        function getDeliveryAddress(order){
          if (order.delivery_address) return String(order.delivery_address).trim();
          if (order.requests) {
            const match = String(order.requests).match(/Delivery Address:\s*([^|]+)/i);
            if (match && match[1]) return match[1].trim();
          }
          return '';
        }

        function getLocationLabel(order){
          if (!order.location) return '';
          try {
            const url = new URL(order.location);
            const query = url.searchParams.get('query');
            if (query) return `Lat/Lng ${decodeURIComponent(query)}`;
          } catch (e) {
            // ignore invalid URL
          }
          return String(order.location);
        }

        function parseLatLngFromLocation(location){
          if (!location) return null;
          try {
            const url = new URL(location);
            const query = url.searchParams.get('query');
            if (!query) return null;
            const parts = query.split(',').map(p => parseFloat(p.trim()));
            if (parts.length >= 2 && isFinite(parts[0]) && isFinite(parts[1])) {
              return { lat: parts[0], lng: parts[1] };
            }
          } catch (e) {
            // ignore invalid URL
          }
          return null;
        }

        function getAddressesWithCoords(){
          return orders
            .map((o, idx) => ({
              id: o.id,
              index: idx,
              address: getDeliveryAddress(o),
              location: o.location,
              coords: parseLatLngFromLocation(o.location),
              customerName: o.customer_name
            }))
            .filter(item => item.coords && item.address);
        }

        function calculateDistance(coord1, coord2){
          const R = 6371;
          const dLat = (coord2.lat - coord1.lat) * Math.PI / 180;
          const dLng = (coord2.lng - coord1.lng) * Math.PI / 180;
          const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                    Math.cos(coord1.lat * Math.PI / 180) * Math.cos(coord2.lat * Math.PI / 180) *
                    Math.sin(dLng / 2) * Math.sin(dLng / 2);
          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
          return R * c;
        }

        function optimizeRoute(){
          const addresses = getAddressesWithCoords();
          if (addresses.length === 0) return alert('No delivery locations with coordinates');
          if (!startingPoint) return alert('Select a starting point');

          setRouteLoading(true);

          let startCoords;
          try {
            startCoords = JSON.parse(startingPoint);
          } catch (e) {
            startCoords = parseLatLngFromLocation(startingPoint);
          }

          if (!startCoords || !isFinite(startCoords.lat) || !isFinite(startCoords.lng)) {
            setRouteLoading(false);
            return alert('Invalid starting point');
          }

          const unvisited = new Set(addresses.map((_, i) => i));
          const route = [{ label: 'START', coords: startCoords, type: 'start' }];
          let current = startCoords;

          while (unvisited.size > 0) {
            let nearest = null;
            let nearestDist = Infinity;
            for (const i of unvisited) {
              const dist = calculateDistance(current, addresses[i].coords);
              if (dist < nearestDist) {
                nearestDist = dist;
                nearest = i;
              }
            }
            if (nearest !== null) {
              const addr = addresses[nearest];
              route.push({
                label: addr.address,
                coords: addr.coords,
                type: 'delivery',
                orderId: addr.id,
                customerName: addr.customerName,
                distFromPrev: nearestDist
              });
              current = addr.coords;
              unvisited.delete(nearest);
            }
          }

          setOptimizedRoute(route);
          setRouteLoading(false);
        }

        function clearRoute(){
          setOptimizedRoute(null);
        }

        function ensureGoogleMaps(){
          if (window.google && window.google.maps) return Promise.resolve();
          const apiKey = window.GOOGLE_MAPS_API_KEY;
          if (!apiKey) return Promise.resolve(false);
          return new Promise((resolve, reject) => {
            const existing = document.getElementById('google-maps-script');
            if (existing) {
              existing.addEventListener('load', () => resolve(true));
              existing.addEventListener('error', reject);
              return;
            }
            const script = document.createElement('script');
            script.id = 'google-maps-script';
            script.async = true;
            script.defer = true;
            script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}`;
            script.onload = () => resolve(true);
            script.onerror = reject;
            document.head.appendChild(script);
          });
        }

        function clearMap(){
          if (mapTypeRef.current === 'google') {
            markersRef.current.forEach(m => m.setMap(null));
            markersRef.current = [];
          }
          if (mapTypeRef.current === 'leaflet' && mapInstanceRef.current) {
            mapInstanceRef.current.remove();
            mapInstanceRef.current = null;
            markersRef.current = [];
          }
        }

        function renderGoogleMarkers(map, locations){
          markersRef.current.forEach(m => m.setMap(null));
          markersRef.current = [];
          locations.forEach((loc) => {
            const marker = new window.google.maps.Marker({
              position: loc,
              map
            });
            markersRef.current.push(marker);
          });
        }

        function renderLeafletMarkers(map, locations){
          if (markersRef.current && markersRef.current.remove) {
            markersRef.current.remove();
          }
          const layer = window.L.layerGroup();
          locations.forEach((loc) => {
            window.L.marker([loc.lat, loc.lng]).addTo(layer);
          });
          layer.addTo(map);
          markersRef.current = layer;
        }

        useEffect(() => {
          if (!mapRef.current) return;
          if (mapApiKey) window.GOOGLE_MAPS_API_KEY = mapApiKey;
          const locations = orders
            .map(o => parseLatLngFromLocation(o.location))
            .filter(Boolean);

          if (locations.length === 0) {
            setMapError('No shared delivery locations found yet.');
          } else {
            setMapError('');
          }

          ensureGoogleMaps()
            .then((googleReady) => {
              if (googleReady) {
                if (mapTypeRef.current !== 'google') {
                  clearMap();
                  mapTypeRef.current = 'google';
                }
                if (!mapInstanceRef.current) {
                  const center = locations[0] || { lat: 18.0179, lng: -76.8099 };
                  mapInstanceRef.current = new window.google.maps.Map(mapRef.current, {
                    center,
                    zoom: locations.length > 0 ? 12 : 10,
                  });
                }
                if (locations.length > 0) {
                  renderGoogleMarkers(mapInstanceRef.current, locations);
                  if (locations.length > 1) {
                    const bounds = new window.google.maps.LatLngBounds();
                    locations.forEach(loc => bounds.extend(loc));
                    mapInstanceRef.current.fitBounds(bounds);
                  } else {
                    mapInstanceRef.current.setCenter(locations[0]);
                    mapInstanceRef.current.setZoom(13);
                  }
                }
                return;
              }

              if (!window.L) {
                setMapError('Leaflet failed to load.');
                return;
              }
              if (mapTypeRef.current !== 'leaflet') {
                clearMap();
                mapTypeRef.current = 'leaflet';
              }
              if (!mapInstanceRef.current) {
                const center = locations[0] || { lat: 18.0179, lng: -76.8099 };
                mapInstanceRef.current = window.L.map(mapRef.current).setView([center.lat, center.lng], locations.length > 0 ? 12 : 10);
                window.L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                  attribution: '&copy; OpenStreetMap contributors'
                }).addTo(mapInstanceRef.current);
              }
              if (locations.length > 0) {
                renderLeafletMarkers(mapInstanceRef.current, locations);
                if (locations.length > 1) {
                  const bounds = window.L.latLngBounds(locations.map(loc => [loc.lat, loc.lng]));
                  mapInstanceRef.current.fitBounds(bounds, { padding: [20, 20] });
                } else {
                  mapInstanceRef.current.setView([locations[0].lat, locations[0].lng], 13);
                }
              }
            })
            .catch(() => {
              if (!window.L) setMapError('Map failed to load.');
            });
        }, [orders, mapApiKey]);

        function getGroupKey(order){
          switch (groupBy) {
            case 'address': {
              const addr = getDeliveryAddress(order);
              return addr || 'No delivery address';
            }
            case 'location': {
              const loc = getLocationLabel(order);
              return loc || 'No location shared';
            }
            case 'delivery_method':
              return order.delivery_method
                ? order.delivery_method.charAt(0).toUpperCase() + order.delivery_method.slice(1)
                : 'Pickup';
            case 'payment_method':
              return order.payment_method
                ? order.payment_method.charAt(0).toUpperCase() + order.payment_method.slice(1)
                : 'Cash';
            default:
              return 'All Orders';
          }
        }

        const groupedOrders = useMemo(() => {
          if (groupBy === 'none') return null;
          const map = new Map();
          orders.forEach((order) => {
            const key = getGroupKey(order);
            if (!map.has(key)) map.set(key, []);
            map.get(key).push(order);
          });
          return Array.from(map.entries()).sort((a, b) => String(a[0]).localeCompare(String(b[0])));
        }, [orders, groupBy]);

        async function addProduct(name, price, image){
          if(!name || !price) return alert('Name and price required');
          try{
              if (!window.supabaseClient) {
              console.error('Supabase not initialized');
              return;
            }
            
              const { data, error } = await window.supabaseClient
              .from('products')
              .insert([{ name, price: parseFloat(price), image, description: '' }])
              .select();
            
            if (error) throw error;
            alert('Product added!');
            fetchProducts();
          }catch(e){
            console.error('addProduct error:', e.message);
            alert('Failed to add product');
          }
        }

        async function updateProduct(id, updates){
          try{
              if (!window.supabaseClient) {
              console.error('Supabase not initialized');
              return;
            }
            
              const { data, error } = await window.supabaseClient
              .from('products')
              .update(updates)
              .eq('id', id)
              .select();
            
            if (error) throw error;
            fetchProducts();
          }catch(e){
            console.error('updateProduct error:', e.message);
            alert('Failed to update product');
          }
        }

        async function deleteOrder(id){
          if(!window.confirm('Are you sure you want to delete this order?')) return;
          
          console.log('=== DELETE ORDER DEBUG ===');
          console.log('Order ID:', id);
          console.log('Order ID type:', typeof id);
          
          try{
            if (!window.supabaseClient) {
              console.error('Supabase not initialized');
              alert('Supabase not initialized');
              return;
            }
            
            console.log('Supabase client ready');
            console.log('Attempting DELETE query...');
            
            const query = window.supabaseClient
              .from('orders')
              .delete()
              .eq('id', id);
            
            console.log('Query built, executing...');
            
            const { data, error, status } = await query;
            
            console.log('Response status:', status);
            console.log('Response data:', data);
            console.log('Response error:', error);
            
            if (error) {
              console.error('Delete failed with error:', error);
              console.error('Error code:', error.code);
              console.error('Error message:', error.message);
              console.error('Error details:', error.details);
              throw error;
            }
            
            if (status === 204 || (data && data.length >= 0)) {
              console.log('DELETE successful - refreshing orders');
              alert('Order deleted successfully');
              await fetchOrders();
            } else {
              console.warn('Unexpected response:', { status, data });
              alert('Delete completed but with unexpected response. Refreshing...');
              await fetchOrders();
            }
          }catch(e){
            console.error('=== DELETE ERROR ===');
            console.error('Error message:', e.message);
            console.error('Error:', e);
            alert('Failed to delete order: ' + (e.message || 'Unknown error'));
            await fetchOrders();
          }
        }
        }

        if(!unlocked) return <SignIn onSuccess={(u) => { setUser(u); setUnlocked(true); }} />;

        async function signOut(){
          try{
            if (window.supabaseClient) {
              await window.supabaseClient.auth.signOut();
            }
          }catch(e){
            console.error('signout error:', e);
          }
          sessionStorage.removeItem('adminSessionId');
          sessionStorage.removeItem('adminEmail');
          window.adminSessionId = null;
          setUser(null);
          setUnlocked(false);
        }

        return (
          <div>
            <header className="mb-6 flex items-center justify-between">
              <h1 className="text-2xl font-semibold">M Cafe — Admin</h1>
              <div className="flex items-center gap-3">
                {user && <div className="text-sm text-gray-600">{user.email}</div>}
                <button onClick={signOut} className="px-3 py-2 border rounded text-sm">Sign out</button>
              </div>
            </header>

            <section className="mb-8 bg-white p-4 rounded-lg shadow">
              <h2 className="text-lg font-medium mb-3">Product Manager</h2>
              <ProductForm onAdded={fetchProducts} addProduct={addProduct} />

                <div className="mt-6">
                <h3 className="font-medium mb-2">Existing Products</h3>
                <div className="space-y-2">
                  {products.map(p => (
                    <ProductRow key={p.id} p={p} onSave={(updates) => updateProduct(p.id, updates)} />
                  ))}
                </div>
              </div>
            </section>

            <section className="bg-white p-4 rounded-lg shadow">
              <div className="flex items-center justify-between mb-3">
                <h2 className="text-lg font-medium">Order History</h2>
                <div className="flex items-center gap-2 text-sm">
                  <label className="text-gray-600">Group by</label>
                  <select
                    value={groupBy}
                    onChange={(e) => setGroupBy(e.target.value)}
                    className="px-2 py-1 border border-gray-200 rounded"
                  >
                    <option value="none">None</option>
                    <option value="address">Delivery Address</option>
                    <option value="location">Shared Location</option>
                    <option value="delivery_method">Delivery Method</option>
                    <option value="payment_method">Payment Method</option>
                  </select>
                </div>
              </div>
              <div className="overflow-auto">
                <table className="w-full text-left text-sm">
                  <thead>
                    <tr className="text-gray-600">
                      <th className="p-2">ID</th>
                      <th className="p-2">Customer</th>
                      <th className="p-2">Items</th>
                      <th className="p-2">Total</th>
                      <th className="p-2">Requests</th>
                      <th className="p-2">Delivery</th>
                      <th className="p-2">Payment</th>
                      <th className="p-2">Location</th>
                      <th className="p-2">Time</th>
                      <th className="p-2">Action</th>
                    </tr>
                  </thead>
                  <tbody>
                    {(groupBy === 'none' ? [['All Orders', orders]] : (groupedOrders || [])).map(([groupKey, groupOrders]) => (
                      <React.Fragment key={groupKey}>
                        {groupBy !== 'none' && (
                          <tr className="bg-gray-50 border-t">
                            <td className="p-2 font-medium text-gray-700" colSpan="10">
                              {groupKey} <span className="text-xs text-gray-500">({groupOrders.length})</span>
                            </td>
                          </tr>
                        )}
                        {groupOrders.map(o => {
                      let parsedItems = [];
                      try {
                        parsedItems = typeof o.items === 'string' ? JSON.parse(o.items) : o.items;
                      } catch (e) {
                        parsedItems = [];
                      }
                      
                      return (
                        <tr key={o.id} className="border-t">
                          <td className="p-2 align-top">{o.id}</td>
                          <td className="p-2 align-top">{o.customer_name || 'N/A'}</td>
                          <td className="p-2 align-top">
                            <div className="text-xs space-y-1">
                              {parsedItems.map((item, idx) => (
                                <div key={idx}>
                                  {item.name} x{item.qty} = ${((item.price || 0) * (item.qty || 0)).toFixed(2)}
                                </div>
                              ))}
                            </div>
                          </td>
                          <td className="p-2 align-top">${o.total}</td>
                          <td className="p-2 align-top">{o.requests || '-'}</td>
                          <td className="p-2 align-top">{o.delivery_method ? o.delivery_method.charAt(0).toUpperCase() + o.delivery_method.slice(1) : 'Pickup'}</td>
                          <td className="p-2 align-top">{o.payment_method ? o.payment_method.charAt(0).toUpperCase() + o.payment_method.slice(1) : 'Cash'}</td>
                          <td className="p-2 align-top">{o.location ? <a href={o.location} target="_blank" rel="noreferrer" className="text-scgreen">Map</a> : '-'}</td>
                          <td className="p-2 align-top">{o.created_at}</td>
                          <td className="p-2 align-top">
                            <button onClick={() => deleteOrder(o.id)} className="px-2 py-1 bg-red-100 text-red-700 rounded text-xs hover:bg-red-200">Delete</button>
                          </td>
                        </tr>
                      );
                    })}
                      </React.Fragment>
                    ))}
                  </tbody>
                </table>
              </div>
            </section>
          </div>
        );
      }

      function ProductRow({p, onSave}){
        const [editing, setEditing] = useState(false);
        const [name, setName] = useState(p.name || '');
        const [price, setPrice] = useState(p.price || 0);
        const [image, setImage] = useState(p.image || '');
        const [displayOrder, setDisplayOrder] = useState(p.display_order || 0);
        const [imageFile, setImageFile] = useState(null);
        const [uploading, setUploading] = useState(false);

        async function handleSave(){
          const pr = parseFloat(price);
          if(!name || name.trim().length === 0) return alert('Name required');
          if(!isFinite(pr) || pr <= 0) return alert('Enter a valid positive price');
          
          let imageUrl = image;
          
          // Upload new image if selected
          if(imageFile){
            try{
              setUploading(true);
              if(!window.supabaseClient) throw new Error('Supabase not initialized');
              
              const fileName = `${Date.now()}-${imageFile.name}`;
              const { data, error } = await window.supabaseClient.storage
                .from('products')
                .upload(fileName, imageFile, {
                  cacheControl: '3600',
                  upsert: false
                });
              
              if(error) throw error;
              
              const { data: { publicUrl } } = window.supabaseClient.storage
                .from('products')
                .getPublicUrl(fileName);
              
              imageUrl = publicUrl;
              setUploading(false);
            }catch(err){
              setUploading(false);
              return alert('Image upload failed: ' + err.message);
            }
          }
          
          onSave({ name, price: pr, image: imageUrl, display_order: parseInt(displayOrder) || 0 });
          setEditing(false);
          setImageFile(null);
        }

        return (
          <div className="border border-gray-200 rounded-lg overflow-hidden bg-white hover:shadow-md transition-shadow">
            <div className="w-full h-40 bg-gray-100 overflow-hidden">
              {image ? <img src={image} alt={name} className="w-full h-full object-cover" /> : <div className="w-full h-full flex items-center justify-center text-gray-300">No image</div>}
            </div>
            <div className="p-3">
              {!editing ? (
                <div>
                  <div className="font-medium text-sm truncate">{name}</div>
                  <div className="text-lg font-semibold text-scgreen">${price}</div>
                  <div className="text-xs text-gray-500">Order: {displayOrder}</div>
                  <button onClick={()=>setEditing(true)} className="mt-2 w-full px-3 py-1 border border-gray-200 rounded text-sm hover:bg-gray-50">Edit</button>
                </div>
              ) : (
                <div className="space-y-2">
                  <div className="grid grid-cols-2 gap-2">
                    <input value={name} onChange={e=>setName(e.target.value)} placeholder="Name" className="px-2 py-1 border rounded" />
                    <input value={price} onChange={e=>setPrice(e.target.value)} placeholder="Price" type="number" step="0.01" className="px-2 py-1 border rounded" />
                  </div>
                  <input value={displayOrder} onChange={e=>setDisplayOrder(e.target.value)} placeholder="Display Order" type="number" className="w-full px-2 py-1 border rounded text-sm" />
                  <div>
                    <input type="file" accept="image/*" onChange={e=>setImageFile(e.target.files[0])} className="text-xs" />
                  </div>
                  <div>
                    <input value={image} onChange={e=>setImage(e.target.value)} placeholder="Or paste image URL" className="w-full px-2 py-1 border rounded text-sm" />
                  </div>
                  <div className="flex gap-2">
                    <button onClick={handleSave} disabled={uploading} className="flex-1 px-2 py-1 bg-scgreen text-white rounded text-sm disabled:opacity-50">{uploading ? 'Uploading...' : 'Save'}</button>
                    <button onClick={()=>setEditing(false)} className="flex-1 px-2 py-1 border rounded text-sm">Cancel</button>
                  </div>
                </div>
              )}
            </div>
          </div>
        );
      }

      function ProductForm({onAdded, addProduct}){
        const [name, setName] = useState('');
        const [price, setPrice] = useState('');
        const [image, setImage] = useState('');
        const [imageFile, setImageFile] = useState(null);
        const [loading, setLoading] = useState(false);
        const [uploadProgress, setUploadProgress] = useState('');

        async function submit(e){
          e.preventDefault();
          const pr = parseFloat(price);
          if(!name || name.trim().length === 0) return alert('Name is required');
          if(!isFinite(pr) || pr <= 0) return alert('Enter a valid price');
          
          setLoading(true);
          let imageUrl = image;
          
          // Upload image file if selected
          if(imageFile){
            try{
              setUploadProgress('Uploading image...');
              if(!window.supabaseClient) throw new Error('Supabase not initialized');
              
              const fileName = `${Date.now()}-${imageFile.name}`;
              const { data, error } = await window.supabaseClient.storage
                .from('products')
                .upload(fileName, imageFile, {
                  cacheControl: '3600',
                  upsert: false
                });
              
              if(error) throw error;
              
              // Get public URL
              const { data: { publicUrl } } = window.supabaseClient.storage
                .from('products')
                .getPublicUrl(fileName);
              
              imageUrl = publicUrl;
              setUploadProgress('Image uploaded!');
            }catch(err){
              setLoading(false);
              setUploadProgress('');
              return alert('Image upload failed: ' + err.message);
            }
          }
          
          setUploadProgress('Saving product...');
          const ok = await addProduct(name, pr, imageUrl);
          setLoading(false);
          setUploadProgress('');
          if(!ok) return;
          setName(''); setPrice(''); setImage(''); setImageFile(null);
        }

        const valid = name.trim().length > 0 && isFinite(parseFloat(price)) && parseFloat(price) > 0;

        return (
          <form onSubmit={submit} className="space-y-3">
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
              <div>
                <label className="block text-sm font-medium">Name</label>
                <input value={name} onChange={e=>setName(e.target.value)} className="mt-1 w-full px-3 py-2 border rounded" />
              </div>
              <div>
                <label className="block text-sm font-medium">Price</label>
                <input value={price} onChange={e=>setPrice(e.target.value)} type="number" step="0.01" className="mt-1 w-full px-3 py-2 border rounded" />
              </div>
            </div>
            <div>
              <label className="block text-sm font-medium">Upload Image</label>
              <input 
                type="file" 
                accept="image/*" 
                onChange={e=>setImageFile(e.target.files[0])} 
                className="mt-1 w-full px-3 py-2 border rounded" 
              />
              <p className="text-xs text-gray-500 mt-1">Upload an image to Supabase storage</p>
            </div>
            <div>
              <label className="block text-sm font-medium">Or Image URL</label>
              <input 
                value={image} 
                onChange={e=>setImage(e.target.value)} 
                placeholder="https://example.com/image.jpg" 
                className="mt-1 w-full px-3 py-2 border rounded" 
              />
              <p className="text-xs text-gray-500 mt-1">Or paste an external image URL</p>
            </div>
            {uploadProgress && <div className="text-sm text-blue-600">{uploadProgress}</div>}
            <div>
              <button type="submit" disabled={!valid || loading} style={{backgroundColor: valid && !loading ? '#00704A' : '#ccc'}} className="px-4 py-2 text-white rounded disabled:opacity-60">{loading ? 'Adding…' : 'Add Product'}</button>
            </div>
          </form>
        );
      }

      function SignIn({onSuccess}){
        const [password, setPassword] = useState('');
        const [loading, setLoading] = useState(false);
        async function submit(e){
          e.preventDefault();
          if(!password || password.trim().length === 0) return alert('Password required');
          setLoading(true);
          try{
            const ADMIN_PASSWORD = window.ADMIN_PASSWORD || 'admin123';
            if(password !== ADMIN_PASSWORD){
              setLoading(false);
              return alert('Invalid password');
            }
            const sessionId = crypto.randomUUID ? crypto.randomUUID() : String(Date.now());
            window.adminSessionId = sessionId;
            sessionStorage.setItem('adminSessionId', sessionId);
            sessionStorage.setItem('adminEmail', 'Admin');
            setLoading(false);
            onSuccess({ email: 'Admin' });
          }catch(e){
            setLoading(false);
            alert('Error: '+e.message);
          }
        }
        return (
          <div className="p-8 max-w-md mx-auto bg-white rounded shadow text-center">
            <h2 className="text-xl font-semibold mb-3">Admin Sign In</h2>
            <form onSubmit={submit} className="space-y-3">
              <input value={password} onChange={e=>setPassword(e.target.value)} placeholder="Password" type="password" className="w-full px-3 py-2 border rounded" />
              <div>
                <button type="submit" style={{backgroundColor: '#00704A'}} className="px-4 py-2 text-white rounded">Sign In</button>
              </div>
            </form>
            <div className="text-sm text-gray-500 mt-3">Enter the admin password configured on the server.</div>
          </div>
        );
      }

      ReactDOM.createRoot(document.getElementById('admin-root')).render(<AdminApp />);
    </script>
  </body>
</html>
